# Nanobrowser Project Understanding Summary

## Project Overview
Nanobrowser is an open-source AI web automation Chrome extension that runs locally in the browser. It serves as a free alternative to OpenAI Operator with flexible LLM options and a multi-agent system.

## Key Features
- **Multi-agent System**: Uses specialized AI agents (Navigator, Planner, Validator) for complex web workflows
- **Interactive Side Panel**: Chat interface with real-time status updates
- **Task Automation**: Automates repetitive web tasks across websites
- **Multiple LLM Support**: Supports OpenAI, Anthropic, Gemini, Ollama, Groq, Cerebras, and custom OpenAI-compatible providers
- **Privacy-Focused**: Everything runs locally, no data shared with cloud services
- **100% Free**: No subscription fees, users only pay for their own API usage

## Project Structure
- `chrome-extension/` - Main Chrome extension code
- `packages/` - Shared packages and utilities
- `pages/` - Additional web pages
- `dist/` - Built extension files (generated after build)

## Technology Stack
- **Framework**: React 18.3.1 with TypeScript
- **Styling**: Tailwind CSS
- **Build Tool**: Vite with Turbo for monorepo management
- **Package Manager**: pnpm (v9.15.1)
- **Target**: Chrome Extension Manifest V3

## Development Setup
- **Node.js**: v22.12.0+ (currently using v23.10.0)
- **pnpm**: v9.15.1+ (currently using v9.15.1)

## Build Commands
- `pnpm install` - Install dependencies ‚úÖ (completed)
- `pnpm dev` - Development build with hot reload ‚úÖ (running in background)
- `pnpm build` - Production build
- `pnpm zip` - Create distribution zip file

## Extension Structure
The built extension includes:
- **manifest.json**: Extension configuration with permissions for storage, scripting, tabs, debugger, and sidePanel
- **background.iife.js**: Service worker for background processes
- **side-panel/**: Main UI interface (React-based)
- **content/**: Content scripts for web page interaction
- **options/**: Extension settings page
- **permission/**: Permission handling
- **Icons**: 32px and 128px extension icons

## Current Status
‚úÖ Dependencies installed
‚úÖ Production build completed successfully
‚úÖ Extension files generated in `dist/` directory
‚úÖ All required files present (content script, manifest, etc.)
‚úÖ Extension name changed to "„Ç®„Ç§„Éä„Éº„ÅÆÊâã" 
‚úÖ **Full Japanese UI localization completed**
üîÑ Ready for Chrome extension loading and testing

## Recent Major Updates

### Custom Template System (Latest)

**Problem Solved**: Replaced the fixed QuickStart items (GitHub star, X follow, AI papers) with a user-friendly custom template system.

**What Changed**:

1. **Updated Default Templates** (`packages/storage/lib/prompt/favorites.ts`):
   - Replaced marketing-focused templates with practical user-focused ones:
     - "üìß Check Daily Emails" - Summarizes important daily emails
     - "üì∞ Daily News Summary" - Creates news summaries from preferred sites  
     - "üìã Create Meeting Notes" - Organizes meeting notes with action items

2. **Enhanced BookmarkList Component** (`pages/side-panel/src/components/BookmarkList.tsx`):
   - Added "+" button in the QuickStart header to create new templates
   - Implemented template creation form with:
     - Title input field
     - Content textarea for task description
     - Save/Cancel buttons with proper validation
   - Added proper focus management for accessibility
   - Added new props: `onBookmarkAdd` callback

3. **Updated SidePanel Integration** (`pages/side-panel/src/SidePanel.tsx`):
   - Added `handleBookmarkAdd` function to save new templates to storage
   - Connected the new template creation flow to the favorites storage system
   - Maintained existing edit, delete, and reorder functionality

4. **Japanese Translations** (`packages/i18n/locales/en/messages.json`):
   - Added complete Japanese translations for template management:
     - `addTemplate`: "„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíËøΩÂä†"
     - `templateTitle`: "„ÉÜ„É≥„Éó„É¨„Éº„Éà„Çø„Ç§„Éà„É´"
     - `templateTitlePlaceholder`: "‰æã: ÊØéÊó•„ÅÆ„É°„Éº„É´„ÉÅ„Çß„ÉÉ„ÇØ"
     - `templateContent`: "„ÉÜ„É≥„Éó„É¨„Éº„ÉàÂÜÖÂÆπ"
     - `templateContentPlaceholder`: "AI„Ç®„Éº„Ç∏„Çß„É≥„Éà„Å´ÂÆüË°å„Åó„Å¶„ÇÇ„Çâ„ÅÑ„Åü„ÅÑ„Çø„Çπ„ÇØ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ..."

**User Experience**: Users can now create personalized task templates for their daily workflows instead of being limited to fixed promotional content. Templates are saved persistently and can be edited, deleted, or reordered as needed.

**Technical Implementation**: Leveraged the existing favorites storage system but enhanced the UI to make template creation more accessible and user-friendly.

### Complete Japanese Localization (Previous)

**Problem Solved**: Users in Japan couldn't use the extension effectively due to English-only interface.

**What Changed**:

1. **Settings Panel Translation**:
   - All settings categories and options now display in Japanese
   - Model selection interfaces, parameter controls, and provider management
   - Enhanced layout to accommodate longer Japanese text (widened sidebar from w-48 to w-56)

2. **Comprehensive Translation Coverage**:
   - General settings terms (maxStepsPerTask, failureTolerance, enableVisionWithHighlighting, etc.)
   - Model interface terms (modelSelection, llmProviders, speechToTextModel, etc.)
   - Agent descriptions (planner, navigator, validator with full descriptions)
   - UI elements (buttons, labels, placeholders, error messages)
   - Provider management terms (apiKey, baseUrl, models, save, cancel, delete, etc.)

3. **Component Updates**:
   - Added `import { t } from '@extension/i18n'` to all relevant components
   - Replaced hardcoded English strings with `t('translationKey')` function calls in:
     - Options.tsx (main settings layout)
     - GeneralSettings.tsx (task and behavior settings)  
     - ModelSettings.tsx (provider and model configuration)

**Technical Details**: Used Chrome extension i18n system with comprehensive Japanese translations in `packages/i18n/locales/en/messages.json`.

### Upstream Merge & Fork Management (Latest)

**Problem Solved**: Successfully merged backend updates from original nanobrowser repository while preserving custom UI/design changes.

**What Was Done**:

1. **Set Up Fork Management** (`FORK_DOCUMENTATION.md`):
   - Created comprehensive documentation explaining this is a fork
   - Added detailed update process for keeping backend in sync with upstream
   - Documented which files to protect (UI customizations) vs. accept (backend changes)
   - Established regular update schedule and emergency recovery procedures

2. **Successful Upstream Merge**:
   - Added original repository as upstream remote
   - Fetched and merged latest commits from nanobrowser/nanobrowser
   - Successfully merged significant backend improvements including:
     - Enhanced first-time user experience with model configuration detection
     - New "Display Highlights" setting for visual feedback
     - Improved navigator agent functionality
     - Better browser page handling and utilities
     - Settings improvements and bug fixes

3. **Conflict Resolution**:
   - **SidePanel.tsx**: Merged new welcome screen for unconfigured models with existing enhanced template system
   - **GeneralSettings.tsx**: Combined new Display Highlights setting with Japanese translations
   - **messages.json**: Added Japanese translations for new Display Highlights feature
   - Preserved all custom UI enhancements while accepting backend improvements

4. **Features Preserved**:
   - ‚úÖ Complete Japanese localization (extended to cover new features)
   - ‚úÖ Enhanced template system with user-customizable templates
   - ‚úÖ Improved layout and UX enhancements
   - ‚úÖ Custom default templates focused on user workflows

5. **New Features Added from Upstream**:
   - ‚úÖ Smart welcome screen for first-time users without configured models
   - ‚úÖ Display Highlights toggle for visual feedback on interactive elements
   - ‚úÖ Enhanced backend stability and performance improvements
   - ‚úÖ Better error handling and user guidance

**Git Setup**:
- `origin`: https://github.com/senseisven/nanobrowser.git (your fork)
- `upstream`: https://github.com/nanobrowser/nanobrowser.git (original repo)

**Future Maintenance**: Regular upstream merges recommended monthly or when critical updates are available, following the process documented in `FORK_DOCUMENTATION.md`.

## Fixed Issues
- ‚úÖ Port 8081 conflict resolved
- ‚úÖ Missing content script file (content/index.iife.js) now built properly
- ‚úÖ _locales directory created successfully
- ‚úÖ Clean production build completed
- ‚úÖ JSX syntax errors in SidePanel component fixed

## Next Steps for Testing
1. Open `chrome://extensions/` in Chrome
2. Enable "Developer mode"
3. Click "Load unpacked" and select the `dist/` folder
4. Configure API keys in the extension settings
5. Test web automation features

## Key Use Cases
- News summarization from websites
- GitHub repository research
- Shopping research and comparison
- General web automation tasks through natural language commands 

### Centralized API Service Implementation (Latest)

**Problem Solved**: Eliminated the need for users to configure API keys by creating a centralized backend service that handles all OpenRouter API calls.

**What Was Done**:

1. **Backend Service Creation** (`backend-service/`):
   - Created Express.js server that proxies OpenRouter API requests
   - Added rate limiting, CORS handling, security headers with Helmet
   - Implemented health checks (`/health`) and usage stats (`/stats`)
   - Added comprehensive error handling and request/response logging
   - Configured for easy deployment on Railway, Render, Vercel, or VPS

2. **New Provider Type** (`packages/storage/lib/settings/types.ts`):
   - Added `ProviderTypeEnum.CentralizedAPI` as new provider type
   - Configured default models (OpenAI GPT-4.1, Claude, Gemini, etc.)
   - Set up default parameters for all three agents (Planner, Navigator, Validator)

3. **Extension Backend Integration**:
   - Updated `chrome-extension/src/background/agent/helper.ts` to handle centralized API
   - Modified LLM provider configuration to skip API key validation for centralized provider
   - Added automatic initialization of centralized provider on extension startup

4. **User Interface Updates**:
   - Added Japanese translations for centralized API ("„Ç®„Ç§„Éä„Éº„ÅÆAI (API„Ç≠„Éº‰∏çË¶Å)")
   - Modified ModelSettings component to disable API key input for centralized provider
   - Added visual indicators showing API key is not required

5. **Configuration Management** (`packages/storage/lib/settings/centralizedApi.ts`):
   - Created dedicated configuration module for centralized API settings
   - Added health check functionality to verify service availability
   - Implemented URL management functions for easy service endpoint updates

6. **Default Provider Setup** (`packages/storage/lib/settings/defaultProviders.ts`):
   - Created functions to automatically configure centralized API provider
   - Added health checking and URL updating capabilities
   - Implemented initialization on extension startup

**Key Benefits**:
- **Zero Configuration**: Users can use the extension immediately without API keys
- **Cost Control**: Centralized billing and usage monitoring
- **Security**: API keys stored securely on server, never exposed to clients
- **Rate Limiting**: Built-in abuse protection and usage management
- **Monitoring**: Comprehensive logging and health checks

**Deployment Options**:
- Railway (recommended for simplicity)
- Render (good for production)
- Vercel (serverless option)
- Custom VPS with PM2

**Files Modified/Added**:
- `backend-service/` - Complete backend service
- `packages/storage/lib/settings/types.ts` - New provider type
- `packages/storage/lib/settings/llmProviders.ts` - Provider configuration
- `packages/storage/lib/settings/centralizedApi.ts` - API configuration
- `packages/storage/lib/settings/defaultProviders.ts` - Setup functions
- `chrome-extension/src/background/agent/helper.ts` - Chat model creation
- `chrome-extension/src/background/index.ts` - Initialization
- `pages/options/src/components/ModelSettings.tsx` - UI updates
- `packages/i18n/locales/en/messages.json` - Japanese translations
- `CENTRALIZED_API_SETUP.md` - Comprehensive deployment guide

**Next Steps for Deployment**:
1. Deploy backend service to hosting platform
2. Update API URLs in configuration files
3. Build and test extension
4. Monitor usage and costs 